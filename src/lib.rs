/*
 * Copyright (c) 2024, Ignacio Slater M.
 * 2-Clause BSD License.
 */
use std::borrow::Cow;
use crate::constraints::constraint::Constraint;

mod constraints;
mod errors;
mod string_scope;

/// A struct representing a clause in a validation process, holding a value and an associated
/// message.
///
/// `ConstraintClause` is a generic struct that pairs a value of type `T` with an error message. 
/// It is primarily used in the context of constraint validation, where the value is checked 
/// against a set of constraints, and the message provides context for any validation errors that
/// occur.
///
/// # Type Parameters
///
/// - `T`: The type of the value being validated. This can be any type, including collections,
///     primitives, or custom types.
///
/// # Lifetimes
///
/// - `'a`: The lifetime of the `message` field. In Rust, lifetimes are a way of ensuring that
///     references do not outlive the data they point to. In this case, the `'a` lifetime ensures
///     that the `message` (which can be a borrowed string slice or an owned string) is valid for at
///     least as long as the `ConstraintClause` itself.
///
/// # Fields
///
/// - `message`: A `Cow<'a, str>` that holds the error message associated with the validation.
///     `Cow` stands for "clone on write" and allows the `message` to be either a borrowed `&str` or
///     an owned `String`. This provides flexibility in how the message is used and reduces
///     unnecessary allocations when possible. In Kotlin, this is somewhat similar to using `String`
///     or `CharSequence`, but Rust's `Cow` provides more control over ownership and borrowing.
///
/// - `value`: The value of type `T` that is being validated. This is the data that will be checked
///     against the constraint. Unlike Kotlin, where ownership is managed by the garbage collector,
///     Rust requires explicit handling of ownership, making it clear when the value is borrowed or
///     owned by the struct.
///
/// # Example
///
/// ```rust
/// use std::borrow::Cow;
///
/// fn main() {
///     let clause = ConstraintClause {
///         message: Cow::Borrowed("Collection size must be 3"),
///         value: vec![1, 2, 3],
///     };
///
///     match clause.must(&HaveSize::with_exact_size(3)) {
///         Ok(_) => println!("Constraint passed."),
///         Err(e) => println!("{}", e),
///     }
/// }
/// ```
#[derive(Debug)]
struct ConstraintClause<'a, T> {
    message: Cow<'a, str>,
    value: T,
}

impl<'a, T> ConstraintClause<'a, T> {
    /// Validates the value against the provided constraint, returning an error if the validation
    /// fails.
    ///
    /// The `must` method is used to enforce a constraint on the value stored within the
    /// `ConstraintClause`. If the value does not satisfy the constraint, an error is returned with
    /// a message that includes the context provided by the `message` field.
    ///
    /// # Parameters
    ///
    /// - `constraint`: A reference to a type that implements the `Constraint<T>` trait. The
    ///     constraint is applied to the value to determine if it meets the required condition.
    ///
    /// # Returns
    ///
    /// - `Ok(())`: If the value satisfies the constraint.
    /// - `Err(String)`: If the value does not satisfy the constraint, with an error message
    ///     generated by the constraint.
    ///
    /// # Example
    ///
    /// ```rust
    /// let clause = ConstraintClause {
    ///     message: Cow::Borrowed("Collection size must be 3"),
    ///     value: vec![1, 2, 3],
    /// };
    ///
    /// let result = clause.must(&HaveSize::with_exact_size(3));
    /// assert!(result.is_ok());
    /// ```
    fn must(&self, constraint: &impl Constraint<T>) -> Result<(), String> {
        if constraint.validate(&self.value) {
            Ok(())
        } else {
            Err(constraint.generate_error_message(&self.message))
        }
    }

    /// Validates that the value does not satisfy the provided constraint, returning an error if it
    /// does.
    ///
    /// The `must_not` method is the inverse of the `must` method. It checks that the value stored
    /// within the `ConstraintClause` does not satisfy the provided constraint. If the value does
    /// satisfy the constraint, an error is returned.
    ///
    /// # Parameters
    ///
    /// - `constraint`: A reference to a type that implements the `Constraint<T>` trait. The
    ///     constraint is applied to the value to determine if it should fail the condition.
    ///
    /// # Returns
    ///
    /// - `Ok(())`: If the value does not satisfy the constraint.
    /// - `Err(String)`: If the value satisfies the constraint, with an error message generated by
    ///     the constraint.
    ///
    /// # Example
    ///
    /// ```rust
    /// let clause = ConstraintClause {
    ///     message: Cow::Borrowed("Collection size must not be 2"),
    ///     value: vec![1, 2, 3],
    /// };
    ///
    /// let result = clause.must_not(&HaveSize::with_exact_size(2));
    /// assert!(result.is_ok());
    /// ```
    fn must_not(&self, constraint: &impl Constraint<T>) -> Result<(), String> {
        if !constraint.validate(&self.value) {
            Ok(())
        } else {
            Err(constraint.generate_error_message(&self.message))
        }
    }
}

/// A macro to create a `ConstraintClause` instance with a message and a value.
///
/// The `constrained!` macro simplifies the creation of a `ConstraintClause`, which pairs a value 
/// with an associated message. This macro can be particularly useful in validation contexts, where 
/// you need to apply constraints to values and provide meaningful error messages if the constraints
/// fail.
///
/// # Syntax
///
/// ```rust
/// constrained!(message, value)
/// ```
///
/// - `message`: An expression representing the message or context for the constraint. This is
///     typically a string slice (`&str`) that explains the purpose or context of the validation.
/// - `value`: An expression representing the value to be validated. This can be any type that you
///     wish to apply constraints to.
///
/// # Example
///
/// ```rust
/// let clause = constrained!("Collection size must be 3", vec![1, 2, 3]);
///
/// match clause.must(&HaveSize::with_exact_size(3)) {
///     Ok(_) => println!("Constraint passed."),
///     Err(e) => println!("{}", e),
/// }
/// ```
///
/// In this example, the `constrained!` macro creates a `ConstraintClause` where the `message` 
/// is `"Collection size must be 3"` and the `value` is a vector containing `[1, 2, 3]`. This clause 
/// can then be validated against a `HaveSize` constraint.
macro_rules! constrained {
    ($message:expr, $value:expr) => {
        ConstraintClause {
            message: ::std::borrow::Cow::from($message),
            value: $value,
        }
    };
}


#[cfg(test)]
mod tests {
    use expectest::prelude::*;
    use crate::constraints::collections::have_size::HaveSize;
    use super::*;

    #[test]
    fn test_can_create_constraint_clause() {
        let clause = constrained!("Test message", 5);
        expect!(clause.message).to(be_equal_to("Test message"));
        expect!(clause.value).to(be_equal_to(5));
    }

    #[test]
    fn test_can_validate_constraint() {
        let clause = constrained!("Test message", vec![1, 2, 3]);
        let result = clause.must(&HaveSize::with_exact_size(3));
        expect!(result).to(be_ok());
    }
    
    #[test]
    fn test_can_validate_constraint_with_error() {
        let clause = constrained!("Test message", vec![1, 2, 3]);
        let result = clause.must(&HaveSize::with_exact_size(2));
        expect!(result).to(be_err());
    }
    
    #[test]
    fn test_can_validate_a_must_not_clause() {
        let clause = constrained!("Test message", vec![1, 2, 3]);
        let result = clause.must_not(&HaveSize::with_exact_size(2));
        expect!(result).to(be_ok());
    }
    
    #[test]
    fn test_can_validate_a_must_not_clause_with_error() {
        let clause = constrained!("Test message", vec![1, 2, 3]);
        let result = clause.must_not(&HaveSize::with_exact_size(3));
        expect!(result).to(be_err());
    }
}
